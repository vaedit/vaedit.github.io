<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>contextmanager</title>
    <url>/2020/09/22/contextmanager/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用contextmanager，设置上下文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBTools_V2</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host=<span class="string">&#x27;192.168.0.188&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;xx&#x27;</span>, user=<span class="string">&#x27;xx&#x27;</span>, passwd=<span class="string">&#x27;xx?&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span></span>):</span></span><br><span class="line">        <span class="comment"># 建立连接</span></span><br><span class="line">        self.conn = pymysql.connect(host=host, port=port, db=db, user=user, passwd=passwd, charset=charset)</span><br><span class="line">        <span class="comment"># 创建游标，操作设置为字典类型</span></span><br><span class="line">        self.cur = self.conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_by_parameters</span>(<span class="params">self, sql, params=None</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(sql, params)</span><br><span class="line">            result = self.cur.fetchall()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_by_parameters</span>(<span class="params">self, sql, params=None</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mysql_connect</span>(<span class="params">host=<span class="string">&#x27;192.168.0.188&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;xx&#x27;</span>, user=<span class="string">&#x27;xx&#x27;</span>, passwd=<span class="string">&#x27;xx?&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># with 执行部分</span></span><br><span class="line">    print(<span class="string">&quot;开始执行&quot;</span>)</span><br><span class="line">    db = DBTools_V2(host=host, port=port, db=db, user=user, passwd=passwd, charset=charset)</span><br><span class="line">    <span class="comment"># as 赋值</span></span><br><span class="line">    <span class="keyword">yield</span> db</span><br><span class="line">    <span class="comment"># 执行完代码后的处理</span></span><br><span class="line">    db.conn.commit()</span><br><span class="line">    db.cur.close()</span><br><span class="line">    db.conn.close()</span><br></pre></td></tr></table></figure>

<a id="more"></a>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql表修复</title>
    <url>/2020/09/22/mysql%E8%A1%A8%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="mysqlcheck"><a href="#mysqlcheck" class="headerlink" title="mysqlcheck"></a>mysqlcheck</h2><blockquote>
<ol>
<li><p>mysqlcheck客户端可以检查和修复MyISAM表。它还可以优化和分析表。mysqlcheck的功能类似myisamchk，但其工作不同。</p>
</li>
<li><p>主要差别是当mysqld服务器在运行时必须使用mysqlcheck，而myisamchk应用于服务器没有运行时。使用mysqlcheck的好处是不需要停止服务器来检查或修复表。</p>
</li>
<li><p>mysqlcheck为用户提供了一种方便的使用SQL语句CHECK TABLE、REPAIR TABLE、ANALYZE TABLE和OPTIMIZE TABLE的方式。它确定在要执行的操作中使用使用哪个语句，然后将语句发送到要执行的服务器上。</p>
</li>
</ol>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlcheck -B 指定数据库 -r -S /data/mysql2/mysql2.sock -u root -p<span class="string">&#x27;test&#x27;</span> &gt;&gt; /var/<span class="built_in">log</span>/mysqlcheck.log</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><p>–optimize，-o  优化表</p>
</li>
<li><p>-h 主机地 </p>
</li>
<li><p>-P 端口号</p>
</li>
<li><p>-F 只检查没有正确关闭的表</p>
</li>
<li><p>-r 执行可以修复大部分问题的修复，只是唯一值不唯一时不能修复。</p>
</li>
<li><p>-a 分析表</p>
</li>
<li><p>-c 检查表，默认选项</p>
</li>
<li><p>-m 中等的检查</p>
</li>
<li><p>-e 完全检查，很慢</p>
</li>
<li><p>–database，-B 指定库 如果没指定，表示全部库</p>
</li>
<li><p>–all–database，-A  所有库</p>
</li>
<li><p>–fast，-F    只检查没有正确关闭的表。</p>
</li>
<li><p>–quick，-q    如果你正使用该选项在检查表，它防止扫描行以检查错误链接的检查。这是最快的检查方法。    如果你正使用该选项在修复表，它尝试只修复索引树。这是最快的修复方法。</p>
</li>
<li><p>–silent，-s    沉默模式。只打印错误消息</p>
</li>
<li><p>–tables    覆盖—database或-B选项。选项后面的所有参量被视为表名。</p>
</li>
<li><p>–socket=/-S   指定套接字</p>
</li>
</ul>
<h2 id="myisamchk"><a href="#myisamchk" class="headerlink" title="myisamchk"></a>myisamchk</h2><blockquote>
<p>myisamchk，只适用于myisam引擎，使用时需要关闭数据库</p>
</blockquote>
<h3 id="myisamchk表损坏原因"><a href="#myisamchk表损坏原因" class="headerlink" title="myisamchk表损坏原因"></a>myisamchk表损坏原因</h3><ol>
<li><p>服务器突然断电导致数据文件损坏;强制关机,没有先关闭mysql 服务;mysqld 进程在写表时被杀掉。因为此时mysql可能正在刷新索引。             </p>
</li>
<li><p>磁盘损坏。             </p>
</li>
<li><p>服务器死机。             </p>
</li>
<li><p>mysql 本身的bug 。             </p>
</li>
</ol>
<h3 id="MySQL中MyISAM表损坏的症状"><a href="#MySQL中MyISAM表损坏的症状" class="headerlink" title="MySQL中MyISAM表损坏的症状"></a>MySQL中MyISAM表损坏的症状</h3><ol>
<li><p>查询数据时报出错误：Incorrect key file for table: ‘…’. Try to repair it </p>
</li>
<li><p>查询不能在表中找到行或返回不完全的数据。             </p>
</li>
<li><p>Error: Table ‘…’ is marked as crashed and should be repaired 。             </p>
</li>
<li><p>打开表失败： Can’t open file: ‘×××.MYI’ (errno: 145) 。</p>
</li>
</ol>
<h3 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h3><ul>
<li>-q 快速修复，一般和-r一起使用，快速修复</li>
<li>-r  修复模式</li>
<li>-o 能修复-r不能修复的问题。一般会有提示使用-o</li>
<li>-i 打印被检测表的信息</li>
<li>-m 中等的检查</li>
<li>-e 最彻底的检查</li>
<li>-a 分析表</li>
<li>-s 安静的</li>
<li>-B 将.MYD文件备份为file_name-time.BAK</li>
<li>–sort-index, -S 以从高到低的顺序排序索引树块。这将优化搜寻并且将使按键值的表扫描更快。</li>
<li>-f  强制修复，一般不使用，可能会有数据丢失</li>
<li>myisamchk默认只用3M的内存来修复，如果要修复大表的话，显然速度会巨慢，我们可以通过为myisamchk设置更多的内存，来使其运行的更快，<br>myisamchk –sort_buffer_size=16M –key_buffer_size=16M –read_buffer_size=1M –write_buffer_size=1M<br>一般sort_buffer_size的大小16m就足够用了。</li>
<li>myisamchk默认使用选项“–tmpdir”作为临时文件的，如果tmpdir指定内存的话，恢复的表比较大，很容易报内存的错误，所以我们可以用tmpdir指定一个比较大的文件系统<br>myisamchk –sort_buffer_size=16m –key_buffer_size=16m  –read_buffer_size=2m –write_buffer_size=1m –tmpdir=/tmp</li>
</ul>
<p>执行myisam表的恢复只要是修复表的三个文件，最常发生问题的文件是数据文件和索引文件</p>
<p>tbl_name.frm：定义(格式)文件<br>tbl_name.MYD：数据文件<br>tbl_name.MYI：索引文件</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>首先进入到对应的数据库下：cd /data/mysql/game | 也可以直接指定表的路径，从而不用进入目录</p>
</blockquote>
<h4 id="检查表"><a href="#检查表" class="headerlink" title="检查表"></a>检查表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快速的检查</span></span><br><span class="line">myisamchk -im /usr/<span class="built_in">local</span>/mysql/data/testx/t2</span><br><span class="line"><span class="comment">#只检查没有正常关闭的表</span></span><br><span class="line">myisamchk -iFm /usr/<span class="built_in">local</span>/mysql/data/testx/t2</span><br><span class="line"><span class="comment">#仅显示表的最重要的信息</span></span><br><span class="line">myisamchk -eim /usr/<span class="built_in">local</span>/mysql/data/testx/t2</span><br></pre></td></tr></table></figure>

<h4 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常用的修复命令</span></span><br><span class="line">myisamchk -rq tbl_name <span class="comment">#快速修复表,只修复索引</span></span><br><span class="line">myisamchk -Br tbl_name  <span class="comment">#备份并修复表</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Xtrabackup</title>
    <url>/2020/09/22/Xtrabackup/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>官方文档地址：<a href="https://www.percona.com/doc/percona-xtrabackup/2.4/">https://www.percona.com/doc/percona-xtrabackup/2.4/</a></p>
</blockquote>
<h3 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h3><ol>
<li>安装Percona源</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm -y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install percona-xtrabackup-24 -y</span><br><span class="line">yum install qpress -y <span class="comment">#压缩备份需要</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h3><ol>
<li>从github获取源码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/percona/percona-xtrabackup.git </span><br><span class="line"><span class="built_in">cd</span> percona-xtrabackup </span><br><span class="line">git checkout 2.4</span><br></pre></td></tr></table></figure>

<p>然后，您应该有一个以您分支的版本命名的目录，例如 <code>percona-xtrabackup</code>。</p>
<ol start="2">
<li>编译安装</li>
</ol>
<ul>
<li>先安装依赖</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install cmake gcc gcc-c++ libaio libaio-devel automake autoconf \ </span><br><span class="line">bison libtool ncurses-devel libgcrypt-devel libev-devel libcurl-devel \ </span><br><span class="line">vim-common</span><br></pre></td></tr></table></figure>

<ul>
<li>编译安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DBUILD_CONFIG = xtrabackup_release -DWITH_MAN_PAGES=OFF &amp;&amp; make -j4</span><br><span class="line">make install <span class="comment">#默认安装/usr/local/xtrabackup</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h3><p>1.下载2进制包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/Percona-XtraBackup-2.4/Percona-XtraBackup-2.4.9/binary/tarball/percona-xtrabackup-2.4.9-Linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<p>2.安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install numactl -y</span><br><span class="line">tar xf percona-xtrabackup-2.4.9-Linux-x86_64.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line">mv /usr/<span class="built_in">local</span>/percona-xtrabackup-2.4.9-Linux-x86_64/ /usr/<span class="built_in">local</span>/xtrabackup</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/xtrabackup/bin&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>



<h2 id="创建备份用户"><a href="#创建备份用户" class="headerlink" title="创建备份用户"></a>创建备份用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;bak&#39;@&#39;localhost&#39; identified by &#39;bak&#39;;</span><br><span class="line">grant reload,lock tables,replication client,process,super on *.* to &#39;bak&#39;@&#39;localhost&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2 id="配置Xtrabackup"><a href="#配置Xtrabackup" class="headerlink" title="配置Xtrabackup"></a>配置Xtrabackup</h2><p>xtrabackup读取配置文件信息在my.cnf的[mysqld]和[xtrabackup]中，如果需要配置xtrabackup的配置只需要在</p>
<p>[xtrabackup]下配置，例如配置默认target_dir</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[xtrabackup]</span><br><span class="line">target_dir &#x3D; &#x2F;data&#x2F;backups&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="完全备份"><a href="#完全备份" class="headerlink" title="完全备份"></a>完全备份</h3><h4 id="创建一次全备"><a href="#创建一次全备" class="headerlink" title="创建一次全备"></a>创建一次全备</h4><blockquote>
<p>2.4之后版本innobackpex将被弃用，所以后续都用xtrabackup</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<h4 id="准备备份文件"><a href="#准备备份文件" class="headerlink" title="准备备份文件"></a>准备备份文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<h4 id="恢复备份到datadir"><a href="#恢复备份到datadir" class="headerlink" title="恢复备份到datadir"></a>恢复备份到datadir</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<p>如果你不想保存备份，可以使用–move-back</p>
<blockquote>
<p>在恢复备份之前，datadir必须为空。另外需要注意的是，在执行恢复之前需要关闭MySQL服务器。您无法还原到正在运行的mysqld实例的datadir（导入部分备份时除外）。</p>
</blockquote>
<p>还可以直接拷贝或者通过rsync来还原备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avrP /data/backup/ /var/lib/mysql/</span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><h4 id="创建一次全备-1"><a href="#创建一次全备-1" class="headerlink" title="创建一次全备"></a>创建一次全备</h4><blockquote>
<p>备份目录上一级目录必须存在，佛则报错</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups/base</span><br></pre></td></tr></table></figure>

<p>备份会在xtrabackup_checkpoints文件中记录LSN和备份方式信息</p>
<h4 id="基于全备的第一次增量备份"><a href="#基于全备的第一次增量备份" class="headerlink" title="基于全备的第一次增量备份"></a>基于全备的第一次增量备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups/inc1 \</span><br><span class="line">--incremental-basedir=/data/backups/base</span><br></pre></td></tr></table></figure>

<h4 id="基于全备的第二次增量备份"><a href="#基于全备的第二次增量备份" class="headerlink" title="基于全备的第二次增量备份"></a>基于全备的第二次增量备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups/inc2 \</span><br><span class="line">--incremental-basedir=/data/backups/inc1</span><br></pre></td></tr></table></figure>

<h4 id="准备备份文件-1"><a href="#准备备份文件-1" class="headerlink" title="准备备份文件"></a>准备备份文件</h4><ol>
<li>先对全备做只提交不回滚</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --apply-log-only --target-dir=/data/backups/base</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把第一次增量备份应用于全备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --apply-log-only --target-dir=/data/backups/base \</span><br><span class="line">--incremental-dir=/data/backups/inc1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>把第二次增量备份应用于已修改的全备（包含第一次增量备份数据）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/base \</span><br><span class="line">--incremental-dir=/data/backups/inc2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：除了最后一次增量备份应用于全备的操作，其余都需要加–apply-log-only,只提交，不回滚。</p>
</blockquote>
<ol start="4">
<li>再对全备做一次–prepare</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/base</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>恢复全备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/backups/base</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><blockquote>
<p>要进行压缩备份，您需要使用 选项：–compress</p>
</blockquote>
<h4 id="创建压缩备份"><a href="#创建压缩备份" class="headerlink" title="创建压缩备份"></a>创建压缩备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --compress --target-dir=/data/compressed/</span><br></pre></td></tr></table></figure>

<p>采用并行压缩加速压缩备份,采用4个压缩线程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --compress --compress-threads=4 \</span><br><span class="line">--target-dir=/data/compressed/</span><br></pre></td></tr></table></figure>

<h4 id="准备备份文件-2"><a href="#准备备份文件-2" class="headerlink" title="准备备份文件"></a>准备备份文件</h4><p>在准备备份之前，您需要解压缩所有文件。 <em>Percona XtraBackup</em>实现了可用于解压缩备份的选项。xtrabackup –decompress</p>
<blockquote>
<p><em>Percona XtraBackup</em>不会自动删除压缩文件。要清理备份目录，您应该使用 选项。即使它们没有被删除，如果使用–copy-back,–rmove-back，这些文件也不会被复制/移动到datadir 。 –remove-original</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --decompress --target-dir=/data/compressed/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在继续之前，您需要确保已安装<a href="http://www.quicklz.com/">qpress</a>。它可从 Percona Software存储库获得 yum install qpress -y</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/compressed/</span><br></pre></td></tr></table></figure>

<h4 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/compressed/</span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="加密备份"><a href="#加密备份" class="headerlink" title="加密备份"></a>加密备份</h3><blockquote>
<p><em>Percona XtraBackup</em>已实现对加密备份的支持。它可用于使用<a href="https://www.percona.com/doc/percona-xtrabackup/2.4/glossary.html#term-xbstream">xbstream</a>选项加密/解密本地或流式备份（不支持流式tar备份），以便为备份添加另一层保护。加密是通过<code>libgcrypt</code>库完成的。</p>
</blockquote>
<p>要进行加密备份，需要指定选项（选项 并且 是互斥的，即只需要提供其中一个）： </p>
<p>–encrypt-key</p>
<p>–encrypt-key-file</p>
<blockquote>
<ul>
<li><code>--encrypt=ALGORITHM</code>-目前支持的算法是： <code>AES128</code>，<code>AES192</code>和<code>AES256</code></li>
<li><code>--encrypt-key=ENCRYPTION_KEY</code> - 使用适当长度的加密密钥。如果命令行无法控制访问机器，则不建议使用此选项，因此可以将密钥视为流程信息的一部分。</li>
<li><code>--encrypt-key-file=KEYFILE</code> - 可以读取适当长度的原始密钥的文件的名称。该文件必须是一个简单的二进制（或文本）文件，其中包含要使用的密钥。</li>
</ul>
</blockquote>
<p>这两个选项， 可用于指定加密密钥:</p>
<p> –encrypt-key</p>
<p> –encrypt-key-file</p>
<p>可以使用以下命令生成加密密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 24</span><br></pre></td></tr></table></figure>

<p>该命令的示例输出应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GCHFLrDFVx6UAsRb88uLVbAVWbK+Yzfs</span><br></pre></td></tr></table></figure>

<p>然后，该值可用作加密密钥</p>
<p><strong>使用–encrypt-key选项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups --encrypt=AES256 \</span><br><span class="line">--encrypt-key=<span class="string">&quot;GCHFLrDFVx6UAsRb88uLVbAVWbK+Yzfs&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用–encrypt-key-file选项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --target-dir=/data/backups/ --encrypt=AES256 \</span><br><span class="line">--encrypt-key-file=/data/backups/keyfile</span><br></pre></td></tr></table></figure>

<h4 id="优化加密备份"><a href="#优化加密备份" class="headerlink" title="优化加密备份"></a>优化加密备份</h4><p>加密备份引入了两个选项，可用于加速加密过程</p>
<p> –encrypt-threads 指定多个线程并行地用于加密</p>
<p> –encrypt-chunk-size  用于指定每个加密线程的工作加密缓冲区的大小（以字节为单位）（默认为64K）</p>
<h4 id="解密加密备份"><a href="#解密加密备份" class="headerlink" title="解密加密备份"></a>解密加密备份</h4><blockquote>
<p>可用于解密备份： –decrypt</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --decrypt=AES256 --encrypt-key=<span class="string">&quot;GCHFLrDFVx6UAsRb88uLVbAVWbK+Yzfs&quot;</span> \</span><br><span class="line">--target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --decrypt=AES256 --encrypt-key=<span class="string">&quot;GCHFLrDFVx6UAsRb88uLVbAVWbK+Yzfs&quot;</span> \</span><br><span class="line">--target-dir=/data/backups/ --remove-original</span><br></pre></td></tr></table></figure>

<h4 id="准备加密备份"><a href="#准备加密备份" class="headerlink" title="准备加密备份"></a>准备加密备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<h4 id="恢复加密备份"><a href="#恢复加密备份" class="headerlink" title="恢复加密备份"></a>恢复加密备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<h3 id="部分备份"><a href="#部分备份" class="headerlink" title="部分备份"></a>部分备份</h3><blockquote>
<p><strong>xtrabackup</strong>支持在启用独立表空间innodb_file_per_table选项时进行部分备份 ，有三种方法</p>
<ol>
<li>将表名与正则表达式匹配</li>
<li>提供文件中的表名列表</li>
<li>提供数据库列表</li>
<li>该表必须是在开启独立表空间后创建的</li>
</ol>
</blockquote>
<h4 id="–tables"><a href="#–tables" class="headerlink" title="–tables"></a>–tables</h4><p>正则匹配所有开头test的库下的所有表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --datadir=/var/lib/mysql --target-dir=/data/backups/ --tables=<span class="string">&quot;^test[.].*&quot;</span></span><br></pre></td></tr></table></figure>

<p>正则匹配开头是test的库下的t1表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --datadir=/var/lib/mysql --target-dir=/data/backups/ --tables=<span class="string">&quot;^test[.]t1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="–tables-file"><a href="#–tables-file" class="headerlink" title="–tables-file"></a>–tables-file</h4><p>以库名.表名格式写入文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mydatabase.mytable&quot;</span> &gt; /tmp/tables.txt</span><br><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --tables-file=/tmp/tables.txt</span><br></pre></td></tr></table></figure>

<h4 id="–databases"><a href="#–databases" class="headerlink" title="–databases"></a>–databases</h4><p>多个库空格分隔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多库备份中，最好同时备份mysql，sys库，这样方便恢复时用户账号信息也存在</span></span><br><span class="line">xtrabackup -H 127.0.0.1 -ubak -pbak -P 3306 --backup --databases=<span class="string">&#x27;mysql sys performance_schema ...&#x27;</span> --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<h4 id="部分备份恢复"><a href="#部分备份恢复" class="headerlink" title="部分备份恢复"></a>部分备份恢复</h4><blockquote>
<p>部分备份有2种方式恢复</p>
<p>1 常规备份恢复</p>
<p>2 –export 单表恢复</p>
</blockquote>
<ol>
<li>常规恢复</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<p>关闭数据库,拷贝数据库目录或者对应的表文件到datadir对应的库或者表,如果直接恢复到一个新实例也可以直接用copy-back.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown mysql.mysql datadir -R</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>–export 单表恢复</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --<span class="built_in">export</span> --target-dir=/data/backups/</span><br></pre></td></tr></table></figure>

<p>然后你能在备份目录中看到.exp文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /data/backups/ -name export_test.*</span><br><span class="line">/data/backups/<span class="built_in">test</span>/export_test.exp </span><br><span class="line">/data/backups/<span class="built_in">test</span>/export_test.ibd </span><br><span class="line">/data/backups/<span class="built_in">test</span>/export_test.cfg</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目标实例必须是mysql5.6版本以上才支持导入单表</p>
</blockquote>
<p>要将表导入其他服务器，首先要创建一个新表，其结构与将在该服务器上导入的表相同：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE mytable (...) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后丢弃它的表空间：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mydatabase.mytable DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure>

<p>复制<code>mytable.ibd</code>和<code>mytable.exp</code>文件到数据库的主页，并导入其表空间：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mydatabase.mytable IMPORT TABLESPACE;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ANALYZE</span> <span class="keyword">TABLE</span> mydatabase.mytable;</span><br></pre></td></tr></table></figure>

<p>运行此命令后，导入表中的数据将可用。</p>
<h3 id="限制备份"><a href="#限制备份" class="headerlink" title="限制备份"></a>限制备份</h3><blockquote>
<p>虽然<strong>xtrabackup</strong>不会阻止数据库的操作，但任何备份都可<strong>以为</strong>正在备份的系统增加负载。在没有太多备用I / O容量的系统上，限制<strong>xtrabackup</strong>读取和写入数据的速率可能会有所帮助。您可以使用该 选项执行此操作。此选项限制每秒复制的块数。块大小为<em>10 MB</em>。</p>
</blockquote>
<p>–throttle=</p>
<p>默认情况下，没有限制，<strong>xtrabackup</strong>尽可能快地读取和写入数据。如果您对IOPS设置了太严格的限制，则备份可能会非常慢，以至于它永远无法跟上InnoDB正在编写的事务日志，因此备份可能永远不会完成。</p>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>默认有两个文件会记录2进制日志信息</p>
<ol>
<li>在只使用XtraDB或InnoDB引擎的情况下，可以在xtrabackup_binlog_pos_innodb中查看</li>
<li>如果有包含其他存储引擎的库（MyisAM），则通过查看xtrabackup_binlog_info </li>
</ol>
<blockquote>
<p>通常情况下只有innodb两个文件2进制一样，如果有其他引擎，则通常xtrabackup_binlog_info 中所示的 position 应该会比 xtrabackup_binlog_pos_innodb 所示的数值大</p>
</blockquote>
<h2 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h2><ul>
<li><p>–apply-log-only</p>
<p>此选项仅在准备备份时执行重做阶段。这对增量备份非常重要。</p>
</li>
<li><p>–backup 进行备份并将其放入。</p>
</li>
<li><p>–compress </p>
<p>此选项告诉<strong>xtrabackup</strong>使用指定的压缩算法压缩所有输出数据，包括事务日志文件和元数据文件。目前唯一支持的算法是quicklz。生成的文件具有qpress存档格式，即*.qp，xtrabackup生成的每个文件本质上都是一个文件的qpress存档，可以通过qpress文件存档提取和解压缩。</p>
</li>
<li><p>–compress-chunk-size=# 压缩线程的工作缓冲区大小（以字节为单位）。默认值为64K。</p>
</li>
<li><p>–compress-threads=# </p>
<p>此选项指定<strong>xtrabackup</strong>用于并行数据压缩的工作线程数。此选项默认为<code>1</code>。并行压缩（：选项：xtrabackup -compress-threads）可以与并行文件复制（）一起使用。例如， 将创建4个I / O线程，这些线程将读取数据并将其传递给2个压缩线程。xtrabackup –parallel –parallel=4 –compress –compress-threads=2</p>
</li>
<li><p>–copy-back 将先前制作的备份中的所有文件从备份目录复制到其原始位置</p>
</li>
<li><p>–databases=#  此选项指定应备份的数据库和表的列表。该选项接受表单列表。`”databasename1[.table_name1] databasename2[.table_name2] . . .”</p>
</li>
<li><p>–datadir=DIRECTORY  备份的源目录。这应该与<em>MySQL</em>服务器的datadir相同，因此<code>my.cnf</code>如果存在则应该从中读取; 否则你必须在命令行上指定它</p>
</li>
<li><p>–decompress </p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql备份</tag>
      </tags>
  </entry>
</search>
